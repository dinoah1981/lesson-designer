#!/usr/bin/env python3
"""
Validate Generated Lesson Materials

Validates both PowerPoint (.pptx) and Word (.docx) files generated by the
lesson designer workflow. Ensures files meet quality requirements before
presenting to teacher.

Checks:
    PowerPoint (.pptx):
    - File exists and can be opened
    - Has minimum number of slides (at least 4: lesson plan + title + objectives + 1 activity)
    - First slide is hidden (lesson plan for teacher) - SLID-02
    - Hidden slide contains required sections (objective, agenda, misconceptions, tips)
    - Font sizes meet 16pt minimum for visible text - SLID-04
    - Title slide has content
    - Discussion slides have time allocations and facilitation notes (Phase 2)

    Word Document (.docx):
    - File exists and can be opened
    - No unrendered Jinja2 template tags ({{ or {%})
    - Has required sections (objectives, activities)
    - Has assessment section - ASMT-01
    - Has minimum paragraph count
    - Answer lines are double-spaced (>= 1.8) (Phase 2)

    Assessment Files (.docx):
    - Rubric tables or answer space present (Phase 2)

Exit codes:
    0 = PASSED - All files valid
    1 = PASSED WITH WARNINGS - Files valid but have minor issues
    2 = FAILED - Critical errors found

Usage:
    python validate_outputs.py <session_directory>
    python validate_outputs.py .lesson-designer/sessions/{session_id}

Requirements covered:
    - SLID-02: Hidden first slide with lesson plan
    - SLID-04: 16pt font minimum
    - ASMT-01: Each lesson includes assessment of its objective
    - Phase 2: Double-spacing for answer lines
    - Phase 2: Discussion facilitation structure
    - Phase 2: Assessment rubrics
"""

import os
import sys
from typing import List, Tuple, Dict, Any

# Import Office document libraries
from pptx import Presentation
from pptx.util import Pt
from docx import Document


def validate_discussion_slides(filepath: str) -> Tuple[List[str], List[str]]:
    """
    Validate discussion slides have proper structure and facilitation notes.

    Phase 2 requirement: Discussion slides should include time allocations
    and presenter notes with facilitation guidance.

    Args:
        filepath: Path to .pptx file

    Returns:
        Tuple of (errors: list, warnings: list)
    """
    errors = []
    warnings = []

    try:
        prs = Presentation(filepath)
    except Exception as e:
        return [], []  # Will be caught by main validation

    # Look for discussion-related slides
    discussion_slides = []
    for i, slide in enumerate(prs.slides):
        if slide._element.get('show') == '0':
            continue  # Skip hidden slides

        slide_text = ''
        for shape in slide.shapes:
            if hasattr(shape, 'text'):
                slide_text += shape.text.lower()

        # Check for discussion indicators
        if any(keyword in slide_text for keyword in ['discussion', 'debrief', 'reflect']):
            discussion_slides.append((i, slide))

    if not discussion_slides:
        # No discussion slides - not an error, just not applicable
        return errors, warnings

    # Validate each discussion slide
    for idx, slide in discussion_slides:
        slide_text = ''
        for shape in slide.shapes:
            if hasattr(shape, 'text'):
                slide_text += shape.text.lower()

        # Check for time allocation (e.g., "5 min", "10 minutes")
        has_time = any(word in slide_text for word in ['min', 'minute'])

        # Check presenter notes for facilitation guidance
        has_notes = slide.has_notes_slide and slide.notes_slide.notes_text_frame.text.strip()
        notes_text = slide.notes_slide.notes_text_frame.text.lower() if has_notes else ''

        # Look for facilitation keywords in notes
        facilitation_keywords = ['time allocation', 'watch for', 'prompts', 'ask', 'facilitate']
        has_facilitation = any(keyword in notes_text for keyword in facilitation_keywords)

        if not has_time:
            warnings.append(f"Discussion slide {idx + 1} missing time allocation")

        if not has_notes:
            warnings.append(f"Discussion slide {idx + 1} missing presenter notes")
        elif not has_facilitation:
            warnings.append(
                f"Discussion slide {idx + 1} notes may be missing facilitation guidance "
                f"(TIME ALLOCATION, WATCH FOR, PROMPTS)"
            )

    return errors, warnings


def validate_assessment(filepath: str) -> Tuple[List[str], List[str]]:
    """
    Validate assessment files have proper structure.

    Phase 2 requirement: Assessment files should include rubrics or answer space.

    Args:
        filepath: Path to .docx file

    Returns:
        Tuple of (errors: list, warnings: list)
    """
    errors = []
    warnings = []

    # Check if file looks like an assessment
    filename = os.path.basename(filepath).lower()
    if not any(keyword in filename for keyword in ['assessment', 'quiz', 'test', 'performance', 'socratic']):
        # Not an assessment file
        return errors, warnings

    try:
        doc = Document(filepath)
    except Exception as e:
        return [], []  # Will be caught by main validation

    # Get all text
    text_parts = []
    for para in doc.paragraphs:
        text_parts.append(para.text)

    for table in doc.tables:
        for row in table.rows:
            for cell in row.cells:
                text_parts.append(cell.text)

    text = '\n'.join(text_parts)
    text_lower = text.lower()

    # Check for rubric indicators
    has_rubric = any(keyword in text_lower for keyword in [
        'rubric', 'criteria', 'advanced', 'proficient', 'developing', 'beginning',
        'points', 'score'
    ])

    # Check for answer space (underscore lines)
    has_answer_space = any('_' in para.text for para in doc.paragraphs)

    if not has_rubric and not has_answer_space:
        warnings.append(
            f"Assessment file may be missing rubric table or answer space"
        )

    return errors, warnings


def validate_pptx(filepath: str) -> Tuple[List[str], List[str]]:
    """
    Validate PowerPoint presentation structure and content.

    Checks:
        1. File exists and can be opened
        2. File size is reasonable
        3. Has minimum number of slides (at least 3)
        4. Has hidden lesson plan slide (SLID-02)
        5. Font sizes meet 16pt minimum where measurable (SLID-04)

    Args:
        filepath: Path to .pptx file

    Returns:
        Tuple of (errors: list, warnings: list)
    """
    errors = []
    warnings = []

    # Check file exists
    if not os.path.exists(filepath):
        errors.append(f"PowerPoint not found: {filepath}")
        return errors, warnings

    # Check file size
    size = os.path.getsize(filepath)
    if size < 5000:
        errors.append(f"PowerPoint too small ({size} bytes), likely corrupt")
        return errors, warnings

    try:
        prs = Presentation(filepath)
    except Exception as e:
        errors.append(f"Invalid PowerPoint file: {e}")
        return errors, warnings

    # Check minimum slides (hidden lesson plan + title + at least 1 content)
    if len(prs.slides) < 3:
        errors.append(f"Too few slides ({len(prs.slides)}), need at least 3")

    # Check for hidden lesson plan slide (SLID-02)
    has_hidden_slide = False
    hidden_slide_idx = None
    for i, slide in enumerate(prs.slides):
        show_value = slide._element.get('show')
        if show_value == '0':
            has_hidden_slide = True
            hidden_slide_idx = i
            break

    if not has_hidden_slide:
        warnings.append("No hidden lesson plan slide found (SLID-02)")
    else:
        # Check hidden slide content has required sections
        hidden_slide = prs.slides[hidden_slide_idx]
        slide_text = ''
        for shape in hidden_slide.shapes:
            if hasattr(shape, 'text'):
                slide_text += shape.text.lower()

        # Check for required lesson plan sections
        required_sections = {
            'objective': 'Objective section',
            'agenda': 'Agenda with timing',
            'misconception': 'Anticipated misconceptions',
            'tip': 'Delivery tips'
        }
        for keyword, description in required_sections.items():
            if keyword not in slide_text:
                warnings.append(f"Hidden lesson plan may be missing {description}")

    # Check title slide (first visible slide)
    first_visible_idx = 0
    for i, slide in enumerate(prs.slides):
        if slide._element.get('show') != '0':
            first_visible_idx = i
            break

    if first_visible_idx < len(prs.slides):
        title_slide = prs.slides[first_visible_idx]
        if not title_slide.shapes.title or not title_slide.shapes.title.text:
            warnings.append("Missing title on first visible slide")

    # Check font sizes (sample first 5 visible slides, SLID-04)
    small_font_count = 0
    visible_slide_count = 0

    for slide in prs.slides:
        if slide._element.get('show') == '0':
            continue  # Skip hidden slides

        visible_slide_count += 1
        if visible_slide_count > 5:
            break  # Sample first 5 visible slides only

        for shape in slide.shapes:
            if hasattr(shape, "text_frame"):
                for paragraph in shape.text_frame.paragraphs:
                    for run in paragraph.runs:
                        if run.font.size and run.font.size < Pt(16):
                            small_font_count += 1

    if small_font_count > 0:
        warnings.append(f"Found {small_font_count} text elements below 16pt minimum (SLID-04)")

    return errors, warnings


def validate_worksheet_spacing(filepath: str) -> Tuple[List[str], List[str]]:
    """
    Validate worksheet has double-spacing for answer lines.

    Phase 2 requirement: Answer lines with underscores should be double-spaced
    to provide adequate room for student writing.

    Args:
        filepath: Path to .docx file

    Returns:
        Tuple of (errors: list, warnings: list)
    """
    errors = []
    warnings = []

    try:
        doc = Document(filepath)
    except Exception as e:
        return [], []  # Will be caught by main validation

    # Find paragraphs with underscore answer lines
    answer_paragraphs = [p for p in doc.paragraphs if '_' in p.text]

    if not answer_paragraphs:
        # No answer lines found - might be simulation or assessment file
        return errors, warnings

    # Check spacing on answer lines
    double_spaced_count = 0
    for para in answer_paragraphs:
        if para.paragraph_format.line_spacing:
            if para.paragraph_format.line_spacing >= 1.8:
                double_spaced_count += 1

    # Expect at least 80% of answer lines to be double-spaced
    expected_threshold = len(answer_paragraphs) * 0.8
    if double_spaced_count < expected_threshold:
        warnings.append(
            f"Worksheet spacing: Only {double_spaced_count}/{len(answer_paragraphs)} "
            f"answer lines are double-spaced (expected >= 1.8 line spacing)"
        )

    return errors, warnings


def validate_docx(filepath: str) -> Tuple[List[str], List[str]]:
    """
    Validate Word document structure and content.

    Checks:
        1. File exists and can be opened
        2. File size is reasonable
        3. No unrendered Jinja2 tags ({{ or {%)
        4. Has required sections (objectives, activities)
        5. Has assessment section (ASMT-01)
        6. Has minimum paragraph count

    Args:
        filepath: Path to .docx file

    Returns:
        Tuple of (errors: list, warnings: list)
    """
    errors = []
    warnings = []

    # Check file exists
    if not os.path.exists(filepath):
        errors.append(f"Word document not found: {filepath}")
        return errors, warnings

    # Check file size
    size = os.path.getsize(filepath)
    if size < 1000:
        errors.append(f"Word document too small ({size} bytes), likely corrupt")
        return errors, warnings

    try:
        doc = Document(filepath)
    except Exception as e:
        errors.append(f"Invalid Word document: {e}")
        return errors, warnings

    # Get all text from document
    text_parts = []
    for para in doc.paragraphs:
        text_parts.append(para.text)

    # Also check tables for text
    for table in doc.tables:
        for row in table.rows:
            for cell in row.cells:
                text_parts.append(cell.text)

    text = '\n'.join(text_parts)
    text_lower = text.lower()

    # Check for unrendered Jinja2 tags (critical error)
    if '{{' in text or '{%' in text:
        errors.append("Unrendered Jinja2 template tags found - template rendering failed")

    # Check for required content sections
    required_sections = {
        'objective': 'Learning Objectives section',
        'activit': 'Activities section',  # Matches 'activity' and 'activities'
    }

    for keyword, description in required_sections.items():
        if keyword not in text_lower:
            warnings.append(f"May be missing {description}")

    # Check for assessment section (ASMT-01) - critical requirement
    assessment_keywords = [
        'exit ticket',
        'assessment',
        'check your understanding',
        'reflection',
        'performance task'
    ]
    has_assessment = any(kw in text_lower for kw in assessment_keywords)

    if not has_assessment:
        errors.append("Missing assessment section (ASMT-01 requires formative assessment)")

    # Check paragraph count (minimum content check)
    para_count = len([p for p in doc.paragraphs if p.text.strip()])
    if para_count < 10:
        warnings.append(f"Document has only {para_count} non-empty paragraphs - may be incomplete")

    return errors, warnings


def generate_validation_report(
    output_dir: str,
    all_errors: List[str],
    all_warnings: List[str],
    file_status: Dict[str, str]
) -> str:
    """
    Generate validation report file.

    Args:
        output_dir: Session directory
        all_errors: List of all errors
        all_warnings: List of all warnings
        file_status: Dict mapping filenames to status

    Returns:
        Path to report file
    """
    report_path = os.path.join(output_dir, '07_validation_report.txt')

    with open(report_path, 'w', encoding='utf-8') as f:
        # Header
        f.write("=" * 60 + "\n")
        f.write("LESSON DESIGNER OUTPUT VALIDATION REPORT\n")
        f.write("=" * 60 + "\n\n")

        # Overall status
        if all_errors:
            f.write("RESULT: FAILED\n")
            f.write(f"  {len(all_errors)} error(s), {len(all_warnings)} warning(s)\n\n")
        elif all_warnings:
            f.write("RESULT: PASSED WITH WARNINGS\n")
            f.write(f"  {len(all_warnings)} warning(s)\n\n")
        else:
            f.write("RESULT: PASSED\n")
            f.write("  All files validated successfully\n\n")

        # File status
        f.write("-" * 60 + "\n")
        f.write("FILE STATUS\n")
        f.write("-" * 60 + "\n")
        for filename, status in file_status.items():
            f.write(f"  {filename}: {status}\n")
        f.write("\n")

        # Errors
        if all_errors:
            f.write("-" * 60 + "\n")
            f.write("ERRORS (must fix before using materials)\n")
            f.write("-" * 60 + "\n")
            for error in all_errors:
                f.write(f"  [ERROR] {error}\n")
            f.write("\n")

        # Warnings
        if all_warnings:
            f.write("-" * 60 + "\n")
            f.write("WARNINGS (review before using materials)\n")
            f.write("-" * 60 + "\n")
            for warning in all_warnings:
                f.write(f"  [WARNING] {warning}\n")
            f.write("\n")

        # Requirements checklist
        f.write("-" * 60 + "\n")
        f.write("REQUIREMENTS CHECKLIST\n")
        f.write("-" * 60 + "\n")

        # Check for specific requirements
        has_hidden_slide_warning = any("hidden lesson plan" in w.lower() for w in all_warnings)
        has_font_warning = any("16pt" in w for w in all_warnings)
        has_assessment_error = any("ASMT-01" in e for e in all_errors)
        has_template_error = any("Jinja2" in e for e in all_errors)

        requirements = [
            ("SLID-02", "Hidden lesson plan slide", not has_hidden_slide_warning),
            ("SLID-04", "16pt minimum font size", not has_font_warning),
            ("MATL-01", "Generated .docx file", "05_slides.pptx" not in str(all_errors)),
            ("ASMT-01", "Formative assessment included", not has_assessment_error),
            ("TMPL-01", "Template rendered correctly", not has_template_error),
        ]

        for req_id, req_desc, passed in requirements:
            status = "PASS" if passed else "FAIL"
            f.write(f"  [{status}] {req_id}: {req_desc}\n")

        f.write("\n" + "=" * 60 + "\n")

    return report_path


def validate_outputs(output_dir: str) -> Tuple[bool, int, int]:
    """
    Validate all generated files in session directory.

    Expected files:
        - 05_slides.pptx
        - 06_worksheet.docx
        - Optional: simulation HTML files
        - Optional: assessment .docx files

    Generates:
        - 07_validation_report.txt

    Args:
        output_dir: Path to session directory

    Returns:
        Tuple of (success: bool, error_count: int, warning_count: int)
    """
    all_errors = []
    all_warnings = []
    file_status = {}

    # Validate PowerPoint
    pptx_path = os.path.join(output_dir, '05_slides.pptx')
    if os.path.exists(pptx_path):
        errors, warnings = validate_pptx(pptx_path)
        all_errors.extend([f"[PowerPoint] {e}" for e in errors])
        all_warnings.extend([f"[PowerPoint] {w}" for w in warnings])

        # Phase 2: Validate discussion slides
        disc_errors, disc_warnings = validate_discussion_slides(pptx_path)
        all_errors.extend([f"[PowerPoint Discussion] {e}" for e in disc_errors])
        all_warnings.extend([f"[PowerPoint Discussion] {w}" for w in disc_warnings])

        file_status['05_slides.pptx'] = 'VALID' if not errors else 'INVALID'
    else:
        all_errors.append("[PowerPoint] Missing: 05_slides.pptx")
        file_status['05_slides.pptx'] = 'MISSING'

    # Validate Word document
    docx_path = os.path.join(output_dir, '06_worksheet.docx')
    if os.path.exists(docx_path):
        errors, warnings = validate_docx(docx_path)
        all_errors.extend([f"[Word] {e}" for e in errors])
        all_warnings.extend([f"[Word] {w}" for w in warnings])

        # Phase 2: Validate worksheet spacing
        spacing_errors, spacing_warnings = validate_worksheet_spacing(docx_path)
        all_errors.extend([f"[Word Spacing] {e}" for e in spacing_errors])
        all_warnings.extend([f"[Word Spacing] {w}" for w in spacing_warnings])

        file_status['06_worksheet.docx'] = 'VALID' if not errors else 'INVALID'
    else:
        all_errors.append("[Word] Missing: 06_worksheet.docx")
        file_status['06_worksheet.docx'] = 'MISSING'

    # Phase 2: Validate assessment files (if present)
    for filename in os.listdir(output_dir):
        if filename.endswith('.docx') and any(keyword in filename.lower() for keyword in ['assessment', 'quiz', 'test', 'performance', 'socratic']):
            assess_path = os.path.join(output_dir, filename)
            assess_errors, assess_warnings = validate_assessment(assess_path)
            all_errors.extend([f"[Assessment - {filename}] {e}" for e in assess_errors])
            all_warnings.extend([f"[Assessment - {filename}] {w}" for w in assess_warnings])
            file_status[filename] = 'VALID' if not assess_errors else 'INVALID'

    # Generate report
    report_path = generate_validation_report(output_dir, all_errors, all_warnings, file_status)

    # Print summary to console
    print("=" * 60)
    print("VALIDATION RESULTS")
    print("=" * 60)

    if all_errors:
        print(f"\nFAILED: {len(all_errors)} error(s)\n")
        for error in all_errors:
            print(f"  [ERROR] {error}")
    else:
        print("\nPASSED")

    if all_warnings:
        print(f"\nWarnings: {len(all_warnings)}\n")
        for warning in all_warnings:
            print(f"  [WARNING] {warning}")

    print(f"\nReport saved to: {report_path}")
    print("=" * 60)

    return len(all_errors) == 0, len(all_errors), len(all_warnings)


def main():
    """CLI entry point."""
    if len(sys.argv) != 2:
        print("Usage: python validate_outputs.py <session_directory>")
        print()
        print("Example:")
        print("  python validate_outputs.py .lesson-designer/sessions/abc123")
        print()
        print("Exit codes:")
        print("  0 = PASSED - All files valid")
        print("  1 = PASSED WITH WARNINGS - Files valid but have minor issues")
        print("  2 = FAILED - Critical errors found")
        sys.exit(1)

    output_dir = sys.argv[1]

    if not os.path.isdir(output_dir):
        print(f"Error: Directory not found: {output_dir}", file=sys.stderr)
        sys.exit(2)

    success, error_count, warning_count = validate_outputs(output_dir)

    if not success:
        sys.exit(2)  # FAILED
    elif warning_count > 0:
        sys.exit(1)  # PASSED WITH WARNINGS
    else:
        sys.exit(0)  # PASSED


if __name__ == "__main__":
    main()
