#!/usr/bin/env python3
"""
Validate Generated Lesson Materials

Validates both PowerPoint (.pptx) and Word (.docx) files generated by the
lesson designer workflow. Ensures files meet quality requirements before
presenting to teacher.

Checks:
    - PowerPoint: hidden slide, minimum slides, font sizes, structure
    - Word: no unrendered tags, assessment section, minimum content

Exit codes:
    0 = PASSED - All files valid
    1 = PASSED WITH WARNINGS - Files valid but have minor issues
    2 = FAILED - Critical errors found

Usage:
    python validate_outputs.py <session_directory>
    python validate_outputs.py .lesson-designer/sessions/{session_id}
"""

import os
import sys
from typing import List, Tuple, Dict, Any

# Import Office document libraries
from pptx import Presentation
from pptx.util import Pt
from docx import Document


def validate_pptx(filepath: str) -> Tuple[List[str], List[str]]:
    """
    Validate PowerPoint presentation structure and content.

    Checks:
        1. File exists and can be opened
        2. File size is reasonable
        3. Has minimum number of slides (at least 3)
        4. Has hidden lesson plan slide (SLID-02)
        5. Font sizes meet 16pt minimum where measurable (SLID-04)

    Args:
        filepath: Path to .pptx file

    Returns:
        Tuple of (errors: list, warnings: list)
    """
    errors = []
    warnings = []

    # Check file exists
    if not os.path.exists(filepath):
        errors.append(f"PowerPoint not found: {filepath}")
        return errors, warnings

    # Check file size
    size = os.path.getsize(filepath)
    if size < 5000:
        errors.append(f"PowerPoint too small ({size} bytes), likely corrupt")
        return errors, warnings

    try:
        prs = Presentation(filepath)
    except Exception as e:
        errors.append(f"Invalid PowerPoint file: {e}")
        return errors, warnings

    # Check minimum slides (hidden lesson plan + title + at least 1 content)
    if len(prs.slides) < 3:
        errors.append(f"Too few slides ({len(prs.slides)}), need at least 3")

    # Check for hidden lesson plan slide (SLID-02)
    has_hidden_slide = False
    for slide in prs.slides:
        show_value = slide._element.get('show')
        if show_value == '0':
            has_hidden_slide = True
            break

    if not has_hidden_slide:
        warnings.append("No hidden lesson plan slide found (SLID-02)")

    # Check title slide (first visible slide)
    first_visible_idx = 0
    for i, slide in enumerate(prs.slides):
        if slide._element.get('show') != '0':
            first_visible_idx = i
            break

    if first_visible_idx < len(prs.slides):
        title_slide = prs.slides[first_visible_idx]
        if not title_slide.shapes.title or not title_slide.shapes.title.text:
            warnings.append("Missing title on first visible slide")

    # Check font sizes (sample first 5 visible slides, SLID-04)
    small_font_count = 0
    visible_slide_count = 0

    for slide in prs.slides:
        if slide._element.get('show') == '0':
            continue  # Skip hidden slides

        visible_slide_count += 1
        if visible_slide_count > 5:
            break  # Sample first 5 visible slides only

        for shape in slide.shapes:
            if hasattr(shape, "text_frame"):
                for paragraph in shape.text_frame.paragraphs:
                    for run in paragraph.runs:
                        if run.font.size and run.font.size < Pt(16):
                            small_font_count += 1

    if small_font_count > 0:
        warnings.append(f"Found {small_font_count} text elements below 16pt minimum (SLID-04)")

    return errors, warnings


def validate_docx(filepath: str) -> Tuple[List[str], List[str]]:
    """
    Validate Word document structure and content.

    Checks:
        1. File exists and can be opened
        2. File size is reasonable
        3. No unrendered Jinja2 tags ({{ or {%)
        4. Has required sections (objectives, activities)
        5. Has assessment section (ASMT-01)
        6. Has minimum paragraph count

    Args:
        filepath: Path to .docx file

    Returns:
        Tuple of (errors: list, warnings: list)
    """
    errors = []
    warnings = []

    # Check file exists
    if not os.path.exists(filepath):
        errors.append(f"Word document not found: {filepath}")
        return errors, warnings

    # Check file size
    size = os.path.getsize(filepath)
    if size < 1000:
        errors.append(f"Word document too small ({size} bytes), likely corrupt")
        return errors, warnings

    try:
        doc = Document(filepath)
    except Exception as e:
        errors.append(f"Invalid Word document: {e}")
        return errors, warnings

    # Get all text from document
    text_parts = []
    for para in doc.paragraphs:
        text_parts.append(para.text)

    # Also check tables for text
    for table in doc.tables:
        for row in table.rows:
            for cell in row.cells:
                text_parts.append(cell.text)

    text = '\n'.join(text_parts)
    text_lower = text.lower()

    # Check for unrendered Jinja2 tags (critical error)
    if '{{' in text or '{%' in text:
        errors.append("Unrendered Jinja2 template tags found - template rendering failed")

    # Check for required content sections
    required_sections = {
        'objective': 'Learning Objectives section',
        'activit': 'Activities section',  # Matches 'activity' and 'activities'
    }

    for keyword, description in required_sections.items():
        if keyword not in text_lower:
            warnings.append(f"May be missing {description}")

    # Check for assessment section (ASMT-01) - critical requirement
    assessment_keywords = [
        'exit ticket',
        'assessment',
        'check your understanding',
        'reflection',
        'performance task'
    ]
    has_assessment = any(kw in text_lower for kw in assessment_keywords)

    if not has_assessment:
        errors.append("Missing assessment section (ASMT-01 requires formative assessment)")

    # Check paragraph count (minimum content check)
    para_count = len([p for p in doc.paragraphs if p.text.strip()])
    if para_count < 10:
        warnings.append(f"Document has only {para_count} non-empty paragraphs - may be incomplete")

    return errors, warnings


def generate_validation_report(
    output_dir: str,
    all_errors: List[str],
    all_warnings: List[str],
    file_status: Dict[str, str]
) -> str:
    """
    Generate validation report file.

    Args:
        output_dir: Session directory
        all_errors: List of all errors
        all_warnings: List of all warnings
        file_status: Dict mapping filenames to status

    Returns:
        Path to report file
    """
    report_path = os.path.join(output_dir, '07_validation_report.txt')

    with open(report_path, 'w', encoding='utf-8') as f:
        # Header
        f.write("=" * 60 + "\n")
        f.write("LESSON DESIGNER OUTPUT VALIDATION REPORT\n")
        f.write("=" * 60 + "\n\n")

        # Overall status
        if all_errors:
            f.write("RESULT: FAILED\n")
            f.write(f"  {len(all_errors)} error(s), {len(all_warnings)} warning(s)\n\n")
        elif all_warnings:
            f.write("RESULT: PASSED WITH WARNINGS\n")
            f.write(f"  {len(all_warnings)} warning(s)\n\n")
        else:
            f.write("RESULT: PASSED\n")
            f.write("  All files validated successfully\n\n")

        # File status
        f.write("-" * 60 + "\n")
        f.write("FILE STATUS\n")
        f.write("-" * 60 + "\n")
        for filename, status in file_status.items():
            f.write(f"  {filename}: {status}\n")
        f.write("\n")

        # Errors
        if all_errors:
            f.write("-" * 60 + "\n")
            f.write("ERRORS (must fix before using materials)\n")
            f.write("-" * 60 + "\n")
            for error in all_errors:
                f.write(f"  [ERROR] {error}\n")
            f.write("\n")

        # Warnings
        if all_warnings:
            f.write("-" * 60 + "\n")
            f.write("WARNINGS (review before using materials)\n")
            f.write("-" * 60 + "\n")
            for warning in all_warnings:
                f.write(f"  [WARNING] {warning}\n")
            f.write("\n")

        # Requirements checklist
        f.write("-" * 60 + "\n")
        f.write("REQUIREMENTS CHECKLIST\n")
        f.write("-" * 60 + "\n")

        # Check for specific requirements
        has_hidden_slide_warning = any("hidden lesson plan" in w.lower() for w in all_warnings)
        has_font_warning = any("16pt" in w for w in all_warnings)
        has_assessment_error = any("ASMT-01" in e for e in all_errors)
        has_template_error = any("Jinja2" in e for e in all_errors)

        requirements = [
            ("SLID-02", "Hidden lesson plan slide", not has_hidden_slide_warning),
            ("SLID-04", "16pt minimum font size", not has_font_warning),
            ("MATL-01", "Generated .docx file", "05_slides.pptx" not in str(all_errors)),
            ("ASMT-01", "Formative assessment included", not has_assessment_error),
            ("TMPL-01", "Template rendered correctly", not has_template_error),
        ]

        for req_id, req_desc, passed in requirements:
            status = "PASS" if passed else "FAIL"
            f.write(f"  [{status}] {req_id}: {req_desc}\n")

        f.write("\n" + "=" * 60 + "\n")

    return report_path


def validate_outputs(output_dir: str) -> Tuple[bool, int, int]:
    """
    Validate all generated files in session directory.

    Expected files:
        - 05_slides.pptx
        - 06_worksheet.docx

    Generates:
        - 07_validation_report.txt

    Args:
        output_dir: Path to session directory

    Returns:
        Tuple of (success: bool, error_count: int, warning_count: int)
    """
    all_errors = []
    all_warnings = []
    file_status = {}

    # Validate PowerPoint
    pptx_path = os.path.join(output_dir, '05_slides.pptx')
    if os.path.exists(pptx_path):
        errors, warnings = validate_pptx(pptx_path)
        all_errors.extend([f"[PowerPoint] {e}" for e in errors])
        all_warnings.extend([f"[PowerPoint] {w}" for w in warnings])
        file_status['05_slides.pptx'] = 'VALID' if not errors else 'INVALID'
    else:
        all_errors.append("[PowerPoint] Missing: 05_slides.pptx")
        file_status['05_slides.pptx'] = 'MISSING'

    # Validate Word document
    docx_path = os.path.join(output_dir, '06_worksheet.docx')
    if os.path.exists(docx_path):
        errors, warnings = validate_docx(docx_path)
        all_errors.extend([f"[Word] {e}" for e in errors])
        all_warnings.extend([f"[Word] {w}" for w in warnings])
        file_status['06_worksheet.docx'] = 'VALID' if not errors else 'INVALID'
    else:
        all_errors.append("[Word] Missing: 06_worksheet.docx")
        file_status['06_worksheet.docx'] = 'MISSING'

    # Generate report
    report_path = generate_validation_report(output_dir, all_errors, all_warnings, file_status)

    # Print summary to console
    print("=" * 60)
    print("VALIDATION RESULTS")
    print("=" * 60)

    if all_errors:
        print(f"\nFAILED: {len(all_errors)} error(s)\n")
        for error in all_errors:
            print(f"  [ERROR] {error}")
    else:
        print("\nPASSED")

    if all_warnings:
        print(f"\nWarnings: {len(all_warnings)}\n")
        for warning in all_warnings:
            print(f"  [WARNING] {warning}")

    print(f"\nReport saved to: {report_path}")
    print("=" * 60)

    return len(all_errors) == 0, len(all_errors), len(all_warnings)


def main():
    """CLI entry point."""
    if len(sys.argv) != 2:
        print("Usage: python validate_outputs.py <session_directory>")
        print()
        print("Example:")
        print("  python validate_outputs.py .lesson-designer/sessions/abc123")
        print()
        print("Exit codes:")
        print("  0 = PASSED - All files valid")
        print("  1 = PASSED WITH WARNINGS - Files valid but have minor issues")
        print("  2 = FAILED - Critical errors found")
        sys.exit(1)

    output_dir = sys.argv[1]

    if not os.path.isdir(output_dir):
        print(f"Error: Directory not found: {output_dir}", file=sys.stderr)
        sys.exit(2)

    success, error_count, warning_count = validate_outputs(output_dir)

    if not success:
        sys.exit(2)  # FAILED
    elif warning_count > 0:
        sys.exit(1)  # PASSED WITH WARNINGS
    else:
        sys.exit(0)  # PASSED


if __name__ == "__main__":
    main()
